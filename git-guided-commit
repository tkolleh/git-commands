#!/bin/zsh
# vim:ft=zsh
#
# git-comm - Interactive conventional commit message generator
#
# Guides users through creating conventional commit messages with type selection,
# scope input, summary, and detailed description using gum for interactive prompts.
#
# Requires: gum (https://github.com/charmbracelet/gum)
#==================================================
#
show_help() {
  printf -- "
git-comm - Interactive conventional commit message generator

Usage: git comm [OPTIONS]

Options:
  -h, --help     Show this help message

Description:
  Interactive command that guides you through creating conventional commit messages.
  Prompts for:
  - Commit type (feat, fix, docs, style, refactor, test, chore, etc.)
  - Scope (optional, often JIRA ticket number)
  - Summary of changes
  - Detailed description (optional)

  Automatically extracts JIRA ticket numbers from branch names when possible.

Conventional Commit Types:
  feat:     A new feature
  fix:      A bug fix
  docs:     Documentation only changes
  style:    Changes that do not affect the meaning of the code
  refactor: A code change that neither fixes a bug nor adds a feature
  test:     Adding missing tests or correcting existing tests
  chore:    Changes to the build process or auxiliary tools
  perf:     A code change that improves performance
  ci:       Changes to CI configuration files and scripts
  build:    Changes that affect the build system or external dependencies
  revert:   Reverts a previous commit

Examples:
  git comm          # Start interactive commit message creation
  git comm --help   # Show this help message

Requirements:
  - gum (https://github.com/charmbracelet/gum) for interactive prompts
  - Git

Environment:
  Automatically detects JIRA ticket numbers from branch names (format: ABC-1234)
"
    exit 0
}

function extract_jira() {
  local branch=${1:-$(git branch --show-current)}
  [[ $branch =~ ([A-Za-z]{3}-[0-9]{4}) ]] && echo $match[1]
}

function git_comm() {
  local _type scope summary description default_scope_jira
  local cache_dir="${TMPDIR:-/tmp}"
  local git_root="$(git rev-parse --show-toplevel)"
  local cache_file="$cache_dir/git-comm-cache-$(echo "$git_root" | sed 's/\//-/g')"
  local cached_summary=""
  local cached_description=""

  if [[ -f "$cache_file" ]]; then
    cached_summary=$(head -n 1 "$cache_file")
    cached_description=$(tail -n +2 "$cache_file")
  fi
  _type=$(gum choose "build" "perf" "ci" "fix" "feat" "docs" "style" "refactor" "test" "chore" "revert")
  default_scope_jira=$(extract_jira)
  scope=$(gum input --placeholder "scope" --value "${default_scope_jira}")

  # Since the scope is optional, wrap it in parentheses if it has a value.
  test -n "$scope" && scope="($scope)"

  # Pre-populate the input with the type(scope): so that the user may change it
  local summary=$(gum input --value "${cached_summary:-${_type}${scope}: }" --placeholder "Summary of this change")
  local description=$(gum write --value "$cached_description" --placeholder "Details of this change (Ctrl+D to finish)")

  # Save summary and description to cache file in case of interruption
  echo "$summary" > "$cache_file"
  echo "$description" >> "$cache_file"

  if [[ -n "$summary" ]]; then
    git commit -m "$summary" -m "$description"
    rm -f "$cache_file"
  else
    echo "Empty commit message, canceling..."
    return 0
  fi
}

function main() {
  case "$1" in
    -h|--help)
      show_help
      ;;
  esac

  local git_status
  git_status=$(git status --porcelain --untracked-files=no)

  if [[ -z $git_status ]]; then
    echo "No changes to commit"
    return 0
  fi

  echo "Modified files:"
  print -r -- "$git_status"
  git_comm
}

main "$@"
