#!/bin/zsh
# vim:ft=zsh
#
# git-st - Enhanced git status with numbered file shortcuts
#
# Processes 'git status --porcelain', and exports numbered env variables that contain 
# the path of each affected file. Integrates with scmpuff if available.
#
# see https://github.com/mroth/scmpuff
#================================================== 
#
show_help() {
  printf -- "
git-st - Enhanced git status command

Usage: git st [OPTIONS]

Options:
  -h,     Show this help message

Description:
  Enhanced git status. One-line status for each file with lines added and removed.
  The Original version by https://www.reddit.com/user/ex1c

Examples:
  git st          # Show status
"
    exit 0
}

check_git_status() {
  local IFS
  local git_status="$(git -c color.status=always status -sb)"

  if [ $? -ne 0 ]; then
      exit 1
  fi

  local diff="$(git diff --color --stat HEAD 2> /dev/null \
  | sed '$d; s/^ //' \
  | cut -d '|' -f 2)"

  IFS=$'\n' git_status=($git_status)
  IFS=$'\n' diff=($diff)

  local len=-1
  for i in $(seq 1 $(( ${#git_status[@]} - 1))); do
      if [ ${#git_status[i]} -gt $len ]
      then
          len=${#git_status[i]}
      fi
  done
  (( len *= -1 ))

  for i in $(seq 0 $(( ${#git_status[@]} - 1))) ; do
      currStatus=${git_status[i]}
      if [ $i -eq 0 ]; then
          echo "${git_status[0]}" | cut -d ' ' -f 2-
      else
          if [ ! -z ${diff[i - 1]} ]; then
              currDiff="|${diff[i - 1]}"
          else
              currDiff=""
          fi
          printf "%*s  %s\n" $len "${currStatus}" "${currDiff}"
      fi
  done

  if [ $(( ${#git_status[@]} - 1)) -eq 0 ]; then
      git -c color.status=always status -b
  fi
}

main() {
    case "$1" in
        -h|--help)
            show_help
            ;;
        *)
            check_git_status "$@"
            ;;
    esac
}

main "$@"
